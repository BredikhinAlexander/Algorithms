\documentclass[a4paper,12pt]{article} % тип документа

% report, book



%  Русский язык

\usepackage[T2A]{fontenc}			% кодировка
\usepackage[utf8]{inputenc}			% кодировка исходного текста
\usepackage[english,russian]{babel}	% локализация и переносы
\usepackage{graphicx}
\graphicspath{{./}}
\DeclareGraphicsExtensions{.png,.jpg}


% Математика
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 


\usepackage{wasysym}

%Заговолок
\author{Бредихин Александр}
\title{Домашняя работа №2}



\begin{document} % начало документа

\maketitle

\subsection*{Задача 1}
Дано: $ g(n) = 1 + c + c^2 + \ldots + c^n $, где $ c > 0 $
\begin{itemize}
\item \textbf{a)} Пусть $ c < 1 $, доказать, что $ g(n) = \Theta(1) $:\\
$\square$ По определению $ \Theta $ оценки:\\
$$ g(n) = \Theta(f(n)) \Leftrightarrow \exists c_1,c_2>0, \exists N \in \mathbb{N}: \forall n>N \longrightarrow 
c_1f(n) \leqslant g(n) \leqslant c_2f(n)$$
В нашем случае $ f(n) = 1 $. Снизу функцию $ g(n) $ можно ограничить первым слагаемым $ 1 $ (так как все слагаемые положительные, то понятно, что $ g(n) = 1 + c + c^2 + \ldots + c^n \geqslant 1 $). Сверху можно ограничить бесконечной суммой (сумма первых $ n $ положительных членов меньше или равна бесконечной суммы), которая является суммой бесконечно убывающей геометрической прогрессией, так как $ c < 1 $. Получается:
$$ g(n)=\sum_{k=0}^{n} c^{k} \leq \sum_{k=0}^{\infty} c^{k}=\frac{1}{1-c}=c_{2} $$
Следовательно мы нашли $ c_{1} = 1, c_2 = \frac{1}{1-c}, N = 1 $ такие, что $c_1 \leqslant g(n) \leqslant c_2  $, значит $ g(n) = \Theta(1) $ по определению.
\begin{flushright}
	$\blacksquare$
\end{flushright}

\item \textbf{b)} Пусть $ c = 1 $, доказать, что $ g(n) = \Theta(n) $:\\
$\square$ Так как $ c = 1 $, то 
$$ g(n) = 1 + c + c^2 + \ldots + c^n = 1 + 1 +\ldots + 1 = n $$
Значит, $ g(n) = \Theta(n) $, по определению $ \Theta $ оценки взяв $  c_{1} = 1, c_2 = 1, N = 1 $
\begin{flushright}
	$\blacksquare$
\end{flushright}

\item \textbf{c)} Пусть $ c > 1 $, доказать, что $ g(n) = \Theta(c^n) $:\\
$\square$ Снизу $ g(n) $ можно ограничить последним слагаемым $ c^n $ (так как все слагаемые положительные, то понятно, что $ g(n) = 1 + c + c^2 + \ldots + c^n \geqslant c^n $). Сверху полуим такую оценку (с помощью формулы суммы геометрической прогрессии) :
$$
\sum_{k=0}^{n-1} c^{k}=\frac{c^{n}-1}{c-1} \leq \frac{c^{n}}{c-1}=c_{2} \cdot c^{n}
$$
$$
\sum_{k=0}^{n} c^{k} \leq c^{n}+\frac{c^{n}}{c-1}=\frac{c}{c-1} \cdot c^{n}
$$
Значит, $ g(n) = \Theta(c^n) $, по определению $ \Theta $ оценки взяв $  c_{1} = 1, c_2 = \frac{c}{c - 1}, N = 1 $
\begin{flushright}
	$\blacksquare$
\end{flushright}

\end{itemize}


\subsection*{Задача 2}
\textbf{a)} для среднего арифметического последовательности чисел индуктивное расширение:
$$ g = \left(\begin{array}{c}{Sum} \\ {n}\end{array}\right), $$
где $Sum$ -- сумма всех элементов последовательности на текущем шаге: первоначально равна 0, затем на каждом шаге прибавляем текущие число последовательности.\\
$n$ - количество элементов в последовательности на текущем шаге, т.е. изначально 0, на каждом шаге прибавляется 1.\\
	Тогда функция $f(g)$ возвращает ответ задачи (индуктивную функцию):
$$f\left( \left[\begin{array}{c}{Sum} \\ {n}\end{array}\right]\right)=\frac{Sum}{n}$$
\textbf{b)} для числа элементов последовательности целых чисел, равных её максимальному элементу индуктивное расширение:
$$g = \left(\begin{array}{c}{Cur\_max} \\ {n}\end{array}\right),$$
где $ Cur\_max $ - максимальный элемент на текущем шаге,\\
$ n $ - количество элементов на текущем шаге, равные $ Cur\_max $\\

Изначально $ Cur\_max $ и $ n $ равны 0, затем на каждом шаге происходит сравнение:
\begin{itemize}
\item если текущий элемент равен $Cur\_max$, то $n += 1$;
\item если текущий элемент больше $Cur\_max$, то присваиваем $Cur\_max$ значение текущего элемента а, $n = 1$;
\item если текущий элемент меньше $Cur\_max$, то ничего не делаем и переходим на следующий шаг
\end{itemize}
Тогда $f(g)$ возвращает ответ задачи (индуктивную функцию):
$$f\left( \left[\begin{array}{c}{Cur\_max} \\ {n}\end{array}\right]\right)= n$$

\textbf{c)} для максимального число идущих подряд одинаковых элементов индуктивное расширение:
$$g = \left(\begin{array}{c}{Cur\_len} \\ {Max\_len} \\ {Cur\_el}\end{array}\right),$$
где $ Cur\_el $ - текущий элемент последовательности (изначально равняется первому элементу последовательности),\\
$Cur\_len$ - длина текущий последовательности одинаковых элементов,\\
$ Max\_len $ - длина максимальной последовательности подряд идущих элементов\\
Изначально $Cur\_len = Max\_len = 0$, на каждом шаге происходит сравнение:
\begin{itemize}
\item если текущий элемент равен $Cur\_el$, то $Cur\_len  $ += 1;
\item если текущий элемент не равен $Cur\_el$, тогда:\\
\begin{itemize}
\item присваиваем $Cur\_el$ значение текущего элемента,
\item если $Cur\_len > Max\_len$, то присваиваем $Max\_len$ значение $Cur\_len$,
\item $Cur\_len = 1$
\end{itemize}
\end{itemize}
Тогда $f(g)$ возвращает ответ задачи (индуктивную функцию):
$$f\left(\left[\begin{array}{c}{Cur\_len} \\ {Max\_len} \\ {Cur\_el}\end{array}\right]\right)= Max\_len$$




\subsection*{Задача 3}

\begin{large}
\hspace{0.1cm} \textit{Алгоритм:}
\end{large}\\
Создадим три указателя: первоначально все они указывают на первые элементы в каждом из трёх массивов и переменную $ count = 0$, в которой будет находиться результат: количество различных элементов в объединение массивов.\\
Сравниваем элементы, на которые указывают указатели, находим наименьший из элементов, прибавляем переменной $ count $ один и сдвигаем указатель(элемент в котором наименьшее число) на следующий элемент массива, если массив заканчивается, то указатель оставляем на месте, но в последующих сравнениях не учитываем этот элемент(аналогично двигаем 2 или 1 других указателя, пока все не дойдут до конца).\\
Если в сравнении получилось, что в двух массивах лежит одинаковые минимальные на текущий момент элементы, то переменную $ count $ увеличиваем на единицу и сдвигаем сразу два указателя на следующие элементы в своих массивах (аналогично, если все 3 элемента равны, прибавляем к переменной 1 и сдвигаем все 3 на следующий элемент). \\
Алгоритм заканчивается, когда все указатели дошли до конца, результат будет находиться в переменной $ count $.\\

\begin{large}
\textit{Корректность:}
\end{large}\\
Пусть мы будем не только считать количество неповторяющихся элементов в объединении, но и находить их, для этого создадим 4ый массив, куда будем класть элемент, который минимальный в сравнении на текущем шаге(если таких элементов одновременно 2 или 3, то все равно кладём 1).\\
Заметим, что в этот массив на каждом шаге мы добавляем наименьший из оставшихся элементов, докажем это по индукции по $ k $-- номеру шага:\\
База индукции: $ k = 1$. Все 3 массива отсортированы по возрастанию, значит первые элементы каждого массива - минимальные в нём, из них выбираем минимальный, значит кладём элемент минимальный из оставшихся.\\
Шаг индукции: пусть на $ k-1 $ шаге утверждение выполнено, тогда указатели указывают на наименьшие элементы в своих массивах, аналогично рассуждению в Б.И. кладём наименьший из оставшихся элементов\\
Из доказанного утверждения следует, что мы не могли <<пропустить никакой элемент>> (так как всегда кладём наименьший из оставшихся) и все они различны, так как не кладём 2 одинаковых не на каком из шагов и массив строго возрастающий, значит алгоритм работает корректно.\\

\begin{large}
\textit{Сложность:}
\end{large}\\
Алгоритм заканчивается, когда каждый указатель дойдёт до конца массива, на каждое перемещение одного указателя в худшем случае приходится сравнение($\mathcal{O}(1)$), следовательно кол-во сравнений в худшем случае равно $ n_1 + n_2 +n_3 $, где $ n_i $ -- количество элементов в $ i $ом массиве, следовательно сложность алгоритма, $\mathcal{O}(n)$(линейная) (где $ n $ максимальная длина из массивов

\subsection*{Задача 4}
Задача: на вход подаётся последовательность чисел $a_1, b_1, a_2, b_2, \ldots, a_n, b_n$, нужно построить онлайн-алгоритм, который вычисляет сумму~$\sum\limits_{ i\neq j} a_i\times b_j$\\
Заметим, что (аналогично идеи из семинара):
$$\sum\limits_{i\neq j} a_i\times b_j = \sum\limits_{ 1 \leq i, j \leq n} a_i\times b_j - \sum\limits_{i = j} a_i\times b_j$$

\begin{equation}\label{otvet}
\sum\limits_{i\neq j} a_i\times b_j = \sum\limits_{i} a_i \sum\limits_{j} b_j - \sum\limits_{ i = j} a_i\times b_j
\end{equation}
Построим индуктивное расширение:
$$g = \left(\begin{array}{c}{S_a} \\ {S_b} \\ {flag}\\ el \\ S_{ab}\end{array}\right),$$
где $ S_a $ -сумма всех чисел $ a_i $,  то есть $S_a = \sum\limits_{i} a_i$, аналогично $ S_b $: $S_b = \sum\limits_{j} b_j$,\\
$ flag $ - переменная, которая показывает какой элемент был считан последним: $flag = 0$ когда считываем элемент <<$a$>>, $flag = 1$ - когда считываем элемент <<$b$>>\\
$el$ - последний считанный элемент <<$a$>>\\
$S_{ab}$ - сумма вида: $S_{ab} = \sum\limits_{ i = j} a_i\times b_j$\\
Алгоритм:\\
Изначально все описанные выше переменные равны 0, начинаем считывать последовательность и выполняем следующие:
\begin{itemize}
\item  Если $flag = 0$ переводим флаг в значение 1, прибавляем текущий элемент к $S_a$, записываем в $el$ значение текущего элемента
\item Если $flag = 1$ переводим флаг в значение 0, прибавляем текущий элемент к $S_b$, значение текущего элемента умножаем на $el$ и прибавляем полученное произведение к $S_{ab}$
\end{itemize}

Функция $f(g)$ возвращает ответ задачи(индуктивную функцию):
$$f\left(\left[\begin{array}{c}{S_a} \\ {S_b} \\ {flag}\\ el \\ S_{ab}\end{array}\right]\right)= S_a \times S_b - S_{ab}$$

Корректность:\\
Из уравнения \eqref{otvet} следует корректность алгоритма: нужно найти 3 указанные суммы, что и делает описанный алгоритм.\\

Сложность:\\
Для вычисления ответа проходим по последовательности длины $ 2n $ (так как $ n $ чисел <<$ a $>> и $ n $ чисел <<$ b $>>) один раз. На каждом шаге делаем арифметические операции сложность которых $\mathcal{O}(1)$, следовательно сложность алгоритма - $\mathcal{O}(n)$(линейная).



\subsection*{Задача 5}
Алгоритм:\\
Создадим массив $ buf $, в котором будем хранить размер максимальной возрастающей подпоследовательность для $ i $го элемента данного в задаче массива $ a $. Изначально массив $ buf $ заполнен единицами (так как сам элемент -- минимальная возрастающая подпоследовательность для семя самого). Пройдёмся по массиву $ a $ двумя вложенными циклами:
$$ for (int \hspace{0.1cm}  i = 0; i < n; i++)$$
$$\hspace{2cm}  for (int \hspace{0.1cm} j = 0; j < i; j++)$$
Принцип динамического программирования:\\
Внутри этого вложенного цикла, находим максимальное из чисел $ buf[j] $, таких что элемент $ a[j] $ удволетворяет условию: $ a[i] > a[j] $ ($ max $) (то есть для скольких предыдущих элементов $ j $ый элемент может являться продолжением подпоследовательности, заканчивающийся $ i $ым элементом и кол-во элементов будет наибольшем на данном этапе). Изменяем массив $ buf[j] += max$ (так как изначально элементы массива уже равны 1, поэтому без $ +1 $)\\
Ответом в задаче будет максимальное число в массиве $ buf $ после прохождения вложенного цикла (частный случай: если $ n = 1 $, выводим 1)\\

Корректность:\\
Так как мы смотрим наилучшее из продолжений только при условии, что $ a[i] > a[j] $, то рассматриваем только строго возрастающие подпоследовательности. На каждом шаге заполнения массива $ buf $ выбираем наибольшую из возможных подпоследовательностей, значит в итоге должна получиться максимальная длина возрастающей последовательности для каждого из чисел массива $ a $\\

Сложность:\\
В алгоритме есть вложенный цикл, проходящий по массиву размером $ n $, значит $ n^2 $ операций на каждой из которых делаем арифмемтические операции, сложность которых $\mathcal{O}(1)$, следовательно сложность алгоритма $\mathcal{O}(n^2)$

\subsection*{Задача 6}
Алгоритм:\\
Создадим 2 переменные:\\
$candidat$ - тут будет лежать элемент, кандитат на нужный нам\\
$flag$ - счётчик\\

Проходимся по массиву циклом и делаем следующие:\\

\begin{itemize}
\item Если переменная $flag$ равна 0, то в переменную $candidat$ кладём текущий элемент, а $flag$ увеличиваем на 1
\item Иначе если текущий элемент равен тому, который в $candidat$, увеличиваем $flag$ на 1
\item во всех остальных случаях уменьшаем $flag$ на 1
\end{itemize}

После этого прохождения по массиву в переменной $condidat$ будет лежать элемент, который встречается более чем $n/2$ раз (majority), если такой в массиве существует (что гарантирует условие задачи)

Корректность:\\
Докажем по индукции, по длине входа -- $ n $:\\
База индукции: $ n = 1 $, очевидно, алгоритм выведет этот единственный элемент в списке, он и является majority, верно\\
Предположение индукции: предположим, что наш алгоритм корректно работает для списков размером до длины $n$. Теперь возьмем список длиной $n + 1$.\\
Шаг индукции. Рассмотрим 2 случая:
\begin{itemize}
\item[1.] В первом случае представим, что первый элемент не является majority. Затем в какой-то момент в этом списке счётчик $flag$ упадет до 0 (так как есть majority элемент, который не равен первоначальному, каждый раз, когда мы его будем встречать счётчик уменьшается на 1, получается, больше $n/2$ минусов, следовательно счётчик обязательно упадёт до 0), и будет выбран новый кандидат. На этом этапе наш алгоритм неотличим от того, что мы начали с этого индекса в массиве. Более того, majority элемент в остальной части нашего списка совпадает с majority элементом в исходном списке, потому что если наш majority элемент появился $k$ раз первоначально в списке из $n$ элементов, то в нашем подсписке из первых $i$ элементов наш majority элемент находится там $\leqslant \frac{i}{2}$ раз. Так как $k > \frac{n}{2}$, то в оставшемся списке длинной $n - i$: 
$k - \frac{i}{2} \geqslant \frac{n - i}{2}$ - верно, значит. Можно пременить наше предположение индукции, как длина <<новой задачи>> меньше либо равна n.

\item[2.] Второй случай: первый элемент-это наш majority элемент. Если весь список обрабатывается без сброса, то, очевидно, был возвращен majority элемент. Если он был сброшен, то мы можем использовать точно такие же рассуждения, как и в пункте 1, чтобы показать, что большинство в подсписке, подлежащем обработке, совпадает с исходным большинством, и поэтому мы все равно будем возвращать правильный элемент.
\end{itemize}

Сложность:\\
Получаем алгоритм сложность которого $\mathcal{O}(n)$, так как проходим по входному списку один раз и на каждом шаге делаем арифмитические операции, сложность которых $\mathcal{O}(1)$\\ 
Сложность по памяти — $\mathcal{O}(1)$ (создаём только 2 новые переменные и не храним входные данные) \\

\end{document} % конец документа