\documentclass[a4paper,12pt]{article} % тип документа

% report, book



%  Русский язык

\usepackage[T2A]{fontenc}			% кодировка
\usepackage[utf8]{inputenc}			% кодировка исходного текста
\usepackage[english,russian]{babel}	% локализация и переносы
\usepackage{graphicx}
\usepackage{tikz}
\graphicspath{{./}}
\DeclareGraphicsExtensions{.png,.jpg}


% Математика
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 


\usepackage{wasysym}

%Заговолок
\author{Бредихин Александр}
\title{Домашняя работа №11}
\date {3 мая 2020 г.}


\begin{document} % начало документа
\maketitle


\subsection*{Задача 1}
\textit{Задача:} Дан неориентированный граф $G = (V,E)$, веса рёбер которого не обязательно различны. Для каждого из утверждений ниже приведите доказательство, если оно истинно, или постройте контрпример, если оно ложно:\\
\begin{itemize}
\item[1) ] Если к каждому ребру графа прибавить вес $w$, то каждое минимальное остовное дерево $G$ перейдёт в минимальное остовное дерево модифицированного графа.\\

\textit{Решение:} это утверждение верно:\\
если пользуемся корректностью алгоритма Крускалы, то добавление к каждому ребру графа веса $w$ на его работу не повлияет (после сортировки по весам рёбра останутся в том же порядке, что и без добавления веса $w$). Следовательно алгоритм найдёт то же минимальное остновное дерево, что и без добавления.\\

Можно рассуждать от противного: пусть после добавления веса $w$ минимальное остовное дерево изменилось и стало $ T'_2 $. Пусть $ T'_1 $ -- дерево из которого оно получилось до добавления весов. В искодном графе $ T_1 $ -- $ MST $, из него получается $ T_2 $ и $ w(T'_2) < w(T_2) $. Так как к каждому ребру мы прибавляем один и тот же вес и количество рёбер в $ T_2 $ и $ T'_2 $ одинаковое, так как это деревья, то верно такие равенства:\\
$ w(T'_2) = w(T'_1) + w \cdot k $\\
$ w(T_2) = w(T_1) + w \cdot k $, $ k $ - количество вершин в дереве\\
так как $ w(T_1) < w(T'_1) $, так как $ T $ - $ MST $. То получаем противоречие с тем, что $ w(T'_2) < w(T_2) $, следовательно наше предположение неверно.

\item[2) ] Если самое лёгкое ребро графа $G$ уникально, то оно входит в любое минимальное остовное дерево.\\

\textit{Решение:} это утверждение верно: это можно сказать сразу из алгоритма Крускала, так как в нём мы сортируем рёбра по весам и берём по порядку, чтобы не образовывалось циклов. Так как ребро уникальное и является самым лёгким, то после сортировки оно окажется первым. \\
То есть мы будем брать его первым, когда ещё ничего не взяли в $ MST $, следовательно, оно точно попадёт в него, так как при его взятии не смогут образоваться циклы (так как в $ MST $ ещё ничего не взято).\\

Можно рассуждать от противного: пусть $ e = (a,b) $ - минимальное уникальное ребро нашего графа. И есть $ T - MST $, такое что $ e \notin T $. Тогда добавим в $ T $ это ребро, появится цикл. Удалим из полученного цикла ребро, которое будет находиться на пути из $ a $ в $ b $ по $ T $ (такой путь точно будет, так как $ T $ - дерево). Получим новое остовное дерево, так как связность и то что охватываем все вершины не нарушится. Но его вес будет меньше $ T $, так как $ w(e) = min $ т оно уникально. Противоречие.

\item[3) ] Если ребро $e$ входит в некоторое минимальное остовное дерево, то оно является самым лёгким ребром из пересекающих некоторый разрез.\\

\textit{Решение:} это утверждение верно:\\
Рассмотрим некотрый разрез и ребро $ e $ которое входит в $T = MST $ нашего графа. От противного: пусть это ребро не минимально и существует ребро $ k $ такое, что $ w(k) < w(e) $.\\
Для этого ребра $ k $ будет верно то, что $ k $ и $ e $ лежат на цикле $ T\cup k $: так как $ T - MST $ содержит все вершины нашего графа и в нём минимальное число рёбер для связности $ T $, если добавляем $ k \notin T $, то получается цикл (если этот цикл будет в одном из подмножеств разреза и нет ребра $ e $, то первоначально дерево не было связным, противоречие). Следовательно циклпроходит через $ k $ и $ e $.\\
Из теории графов если удалим любое ребро цикла, то граф на этих вершинах останется связным. Удаляем ребро $ e $, получаем новое остовное дерево (так как в нём нет циклов и оно проходит через все вершины), но вес нового остновного дерева будет меньше, чем первоначального, так как $ w(k) < w(e) $. Получили противоречие, следовательно, ребро $ e $ является самым лёгким ребром из пересекающих разрез.

\item[4) ] Кратчайший путь между двумя вершинами является частью некоторого минимального остовного дерева.\\

\textit{Решение:} это утверждение неверно, приведём контрпример (из семинара):
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (20.2,-15.5) circle (3);
\draw (20.2,-15.5) node {$a$};
\draw [black] (44.2,-15.5) circle (3);
\draw (44.2,-15.5) node {$b$};
\draw [black] (20.2,-31.7) circle (3);
\draw (20.2,-31.7) node {$c$};
\draw [black] (44.5,-31.7) circle (3);
\draw (44.5,-31.7) node {$d$};
\draw [black] (23.2,-15.5) -- (41.2,-15.5);
\fill [black] (41.2,-15.5) -- (40.4,-15) -- (40.4,-16);
\draw (32.2,-16) node [below] {$1$};
\draw [black] (41.2,-15.5) -- (23.2,-15.5);
\fill [black] (23.2,-15.5) -- (24,-16) -- (24,-15);
\draw [black] (44.26,-18.5) -- (44.44,-28.7);
\fill [black] (44.44,-28.7) -- (44.93,-27.89) -- (43.93,-27.91);
\draw [black] (44.44,-28.7) -- (44.26,-18.5);
\fill [black] (44.26,-18.5) -- (43.77,-19.31) -- (44.77,-19.29);
\draw (44.88,-23.6) node [right] {$1.5$};
\draw [black] (23.2,-31.7) -- (41.5,-31.7);
\fill [black] (41.5,-31.7) -- (40.7,-31.2) -- (40.7,-32.2);
\draw (32.35,-32.2) node [below] {$1.5$};
\draw [black] (41.5,-31.7) -- (23.2,-31.7);
\fill [black] (23.2,-31.7) -- (24,-32.2) -- (24,-31.2);
\draw [black] (22.69,-30.02) -- (41.71,-17.18);
\fill [black] (41.71,-17.18) -- (40.77,-17.21) -- (41.33,-18.04);
\draw [black] (41.71,-17.18) -- (22.69,-30.02);
\fill [black] (22.69,-30.02) -- (23.63,-29.99) -- (23.07,-29.16);
\draw (31.2,-23.1) node [above] {$1$};
\draw [black] (22.7,-17.16) -- (42,-30.04);
\fill [black] (42,-30.04) -- (41.62,-29.18) -- (41.06,-30.01);
\draw [black] (42,-30.04) -- (22.7,-17.16);
\fill [black] (22.7,-17.16) -- (23.08,-18.02) -- (23.64,-17.19);
\draw (33.35,-23.1) node [above] {$1$};
\draw [black] (20.2,-28.7) -- (20.2,-18.5);
\fill [black] (20.2,-18.5) -- (19.7,-19.3) -- (20.7,-19.3);
\draw (20.7,-23.6) node [right] {$1.5$};
\draw [black] (20.2,-18.5) -- (20.2,-28.7);
\fill [black] (20.2,-28.7) -- (20.7,-27.9) -- (19.7,-27.9);
\end{tikzpicture}
\end{center}

Для такого графа $ MST $ (с помощью алгоритма Крускала) будет выглядить так:
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
\draw [black] (20.2,-15.5) circle (3);
\draw (20.2,-15.5) node {$a$};
\draw [black] (44.2,-15.5) circle (3);
\draw (44.2,-15.5) node {$b$};
\draw [black] (20.2,-31.7) circle (3);
\draw (20.2,-31.7) node {$c$};
\draw [black] (44.5,-31.7) circle (3);
\draw (44.5,-31.7) node {$d$};
\draw [black] (23.2,-15.5) -- (41.2,-15.5);
\fill [black] (41.2,-15.5) -- (40.4,-15) -- (40.4,-16);
\draw (32.2,-16) node [below] {$1$};
\draw [black] (41.2,-15.5) -- (23.2,-15.5);
\fill [black] (23.2,-15.5) -- (24,-16) -- (24,-15);
\draw [black] (22.69,-30.02) -- (41.71,-17.18);
\fill [black] (41.71,-17.18) -- (40.77,-17.21) -- (41.33,-18.04);
\draw [black] (41.71,-17.18) -- (22.69,-30.02);
\fill [black] (22.69,-30.02) -- (23.63,-29.99) -- (23.07,-29.16);
\draw (31.2,-23.1) node [above] {$1$};
\draw [black] (22.7,-17.16) -- (42,-30.04);
\fill [black] (42,-30.04) -- (41.62,-29.18) -- (41.06,-30.01);
\draw [black] (42,-30.04) -- (22.7,-17.16);
\fill [black] (22.7,-17.16) -- (23.08,-18.02) -- (23.64,-17.19);
\draw (33.35,-23.1) node [above] {$1$};
\end{tikzpicture}
\end{center}
Минимальным путём между вершинами $ c $ и $ d $ будет ребро $ cd $ (с помощью алгоритма Дейкстры, так как все веса рёбер положительные), которого нет в $ MST $, следовательно, кратчайший путь между двумя вершинами \textbf{НЕ}является частью некоторого минимального остовного дерева.

\end{itemize}

\subsection*{Задача 2}
\textit{Задача:}  пусть $T$ "--- минимальное остовное дерево графа $G$, а $H$ "--- связный подграф $G$. Покажите, что рёбра, входящие как в $T$, так и в $H$, входят в некоторое минимальное остовное дерево графа~$H$.\\

Рассматриваем рёбра $ E $, которые будут пересечением рёбер остовного дерева $ G $ и множеством рёбер $ H $. $ T_H $ -- минимальное остовное дерево для подграфа $ H $, пусть $ T_H = E $. А далее будем действовать аналогично алгоритму Крускала: сортируем оставшиеся рёбра. Добавляем рёбра в $ T_H $  с минимальным весом чтобы не появлялись циклы. Получим остовное дерево (так как для $ H $ - остовное дерево и затем действуем алгоритмом Крускала), докажем, что полученное этими действиями остовное дерево будет минимально для всего графа.\\

От противного: пусть $ T'_H $ -- $ MST $ (а не $ T_H $). Тогда вместо дерева $ T_H $ поставим $ T'_H $ получим новое дерево $ T' $. Это дерево, так как в нём нет циклов: по построению в $ Tэ_H $ нет циклов и рёбра из $ H $ лежащие в $  T $ принадлежат различным компонентам связности.\\
Также $ T' $ -- остовное дерево, так как оно содержит все рёбра графа $ G $: $ T'_H $ - остовное дерево, дальше по построению. Получим остовное дерево, меньше, чем $ T $ -- противоречие, что $ T - MST $, следовательно, наше предположение неверно и $ T_H $ -- $ MST $ подграфа $ H $, которое содержит все $ E $. То что нам и требовалось показать.


\subsection*{Задача 3}
\textit{Задача:}  рассмотрим алгоритм Union-Find без улучшения со сжатием путей\footnote{При вызове $\mathrm{Find}(x)$ все предки $x$ вместе с $x$ становятся детьми корня.}. Приведите последовательность из $m$ операций Union и Find над множеством из $n$ элементов, которая потребует времени $\Omega(m\log n)$.\\

С помощью операций Union-Find получим бинарное дерево следующим способом: (б.о.о считаем, что количество вершин это точная степень двойки) сначала объединяем вершины по парам, затем обединяем каждые пары друг с другом и так далее. Заметим, что на $ k $ой итерации все корни имеют ранг $ k $ а сумма длин всех путей до корня будет равна $ \frac{n}{2} \cdot k $. Это можно проверить с помощью индукции:\\

Б.И. $ k = 1 $ - верно.\\
Ш.И. пусть на $ k $ой итерации все корни имеют одинаковый ранг, то при следующем попарном объединении множеств ранг будет увеличиваться на 1 у всех получившихся корней (по определению операции Union), следовательно, на $ k+1 $ом шаге ранг каждого корне равняется $ k+1 $.\\
Заметим, что при объединении двух множеств один из корней станет на 1 выше другого, следовательно путь до нового корня от каждой вершины множества, чей корень окажется ниже увеличится на 1. По построению во всех множествах будет одинаковое количество элементов, следовательно, путь увеличится у половины вершин. Следовательно, сумма всех путей станет $ \frac{n}{2} \cdot (k+1) $. То есть доказали шаг индукции.\\

Посчитаем количество Union-Find в таком случае. Их получается $ 2n $. Всего итераций (так как бинарное дерево) было $ k = \log n $. Следовательно, из того что сумма всех путей до корня равна $ \frac{n}{2} \cdot k $ все поиски будут выполняться за $ n \log n $. Поэтому оценка работы алгоритма (с учётом того, что $ m = 2n $) получается: $ \Theta(m \log n) $, что и требовалось показать.

\subsection*{Задача 4}
\textit{Задача:} на вход задачи подаётся неориентированный взвешенный граф $G(V,E)$ и подмножество вершин $U \subseteq V$. Необходимо построить остовное дерево, минимальное (по весу) среди деревьев, в которых все вершины $U$ являются листьями (но могут быть и другие листья) или обнаружить, что таких остовных деревьев нет. Постройте алгоритм, который решает задачу за $O(|E|\log |V|)$. Обратите внимание, что искомое дерево может не быть минимальным остовным деревом.\\

Алгоритм: найдём (например, алгоритмом Крускала или Примы) минимальное остовное дерево на подграфе $ V  \backslash U $. (если такого нет, то искомого дерева не будет). Затем смотрим на разрез $ U $ и $ V  \backslash U $ и находим для каждой вершины из $ U $ минимальное по весу ребро, которое пересекает рассматриваемый разрез и добавляем его к полученному алгоритму дереву.\\

Корректность: если мы удалим из дерева листы, то оно все равно останется деревом. Нам нужно найти $ MST $ с листьями из $ U $, поэтому на подграфе $ V  \backslash U $ остовное дерево должно быть минимальным (так как оно индуцирует $ MST $, которое нам нужно) (если это не так и есть другое дерево, которое удволетворяет условиям задачи, то если мы уберём из него все листья, то получим дерево на подграфе $ V  \backslash U $ котрое должно быть минимальным, противоречие) (и оно должно быть, так как иначе при добавлении листьев связность не появится: по определению листа).\\ 
Также после нахождения дерева на подграфе $ V  \backslash U $ присоединяем к нему каждый лист минимальным образом (по минимальному ребру в разрезе). Поэтому получаем минимальное остовное дерево, удволетворяющее условию задачи.\\

Сложность: ищем минимальное дерево за $ O(|E| \log(|V|)) $ (сложность алгоритма Примы, считаем, что $ |U| $ не влияет на асимптотику). Последующее добавление листьев в худшем случае занимает $ O(|E|) $. Суммарно $ O(|E| \log(|V|)) $

\end{document} % конец документа